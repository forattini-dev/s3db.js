/**
 * VulnerabilityStage
 *
 * Vulnerability scanning using RedBlue:
 * - Web vulnerability detection
 * - CMS-specific scanning (WordPress, Drupal, Joomla)
 * - Auto-detection of CMS type
 */

import type { CommandRunner } from '../concerns/command-runner.js';

export interface ReconPlugin {
  commandRunner: CommandRunner;
  config: Record<string, any>;
}

export interface Target {
  host: string;
  protocol?: string;
  port?: number;
  path?: string;
}

export interface VulnerabilityFeatureConfig {
  timeout?: number;
  strategy?: string;
  aggressive?: boolean;
}

export interface Vulnerability {
  title: string;
  severity: string;
  cve?: string | null;
  cvss?: number | null;
  description?: string | null;
  evidence?: string | null;
  recommendation?: string | null;
  references?: string[];
}

export interface VulnerabilitiesData {
  vulnerabilities: Vulnerability[];
  total: number;
  cms?: string | null;
  version?: string | null;
  summary?: any | null;
}

export interface VulnerabilityResult {
  status: 'ok' | 'empty' | 'unavailable' | 'error';
  message?: string;
  url?: string;
  vulnerabilities?: Vulnerability[];
  total?: number;
  cms?: string | null;
  version?: string | null;
  summary?: any | null;
  metadata?: Record<string, any>;
}

export class VulnerabilityStage {
  private plugin: ReconPlugin;
  private commandRunner: CommandRunner;
  private config: ReconPlugin['config'];

  constructor(plugin: ReconPlugin) {
    this.plugin = plugin;
    this.commandRunner = plugin.commandRunner;
    this.config = plugin.config;
  }

  async execute(target: Target, featureConfig: VulnerabilityFeatureConfig = {}): Promise<VulnerabilityResult> {
    const url = this._buildUrl(target);
    const strategy = featureConfig.strategy || 'auto';

    const result = await this.commandRunner.runRedBlue(
      'web',
      'asset',
      'scan',
      url,
      {
        timeout: featureConfig.timeout || 120000,
        flags: this._buildFlags(strategy, featureConfig)
      }
    );

    if (result.status === 'unavailable') {
      return {
        status: 'unavailable',
        message: 'RedBlue (rb) is not available',
        metadata: result.metadata
      };
    }

    if (result.status === 'error') {
      return {
        status: 'error',
        message: result.error,
        metadata: result.metadata
      };
    }

    const vulns = this._normalizeVulnerabilities(result.data);

    return {
      status: vulns.total > 0 ? 'ok' : 'empty',
      url,
      ...vulns,
      metadata: result.metadata
    };
  }

  private _buildUrl(target: Target): string {
    const protocol = target.protocol || 'https';
    const port = target.port && target.port !== (protocol === 'http' ? 80 : 443)
      ? `:${target.port}`
      : '';
    return `${protocol}://${target.host}${port}${target.path || ''}`;
  }

  private _buildFlags(strategy: string, config: VulnerabilityFeatureConfig): string[] {
    const flags: string[] = [];

    if (strategy !== 'auto') {
      flags.push('--strategy', strategy);
    }

    if (config.aggressive) {
      flags.push('--aggressive');
    }

    return flags;
  }

  private _normalizeVulnerabilities(data: any): VulnerabilitiesData {
    if (!data || typeof data !== 'object') {
      return { vulnerabilities: [], total: 0 };
    }

    if (data.raw) {
      return this._parseRawVulns(data.raw);
    }

    const vulnerabilities: Vulnerability[] = [];

    if (Array.isArray(data.vulnerabilities)) {
      vulnerabilities.push(...data.vulnerabilities.map((v: any) => this._normalizeVuln(v)).filter(Boolean));
    } else if (Array.isArray(data)) {
      vulnerabilities.push(...data.map((v: any) => this._normalizeVuln(v)).filter((v): v is Vulnerability => v !== null));
    }

    if (data.findings) {
      vulnerabilities.push(...data.findings.map((v: any) => this._normalizeVuln(v)).filter(Boolean));
    }

    return {
      vulnerabilities: vulnerabilities.filter((v): v is Vulnerability => v !== null),
      total: vulnerabilities.length,
      cms: data.cms || data.detected_cms || null,
      version: data.version || data.detected_version || null,
      summary: data.summary || null
    };
  }

  private _normalizeVuln(vuln: any): Vulnerability | null {
    if (!vuln) return null;

    if (typeof vuln === 'string') {
      return { title: vuln, severity: 'unknown' };
    }

    return {
      title: vuln.title || vuln.name || vuln.description || 'Unknown vulnerability',
      severity: vuln.severity || vuln.risk || this._inferSeverity(vuln),
      cve: vuln.cve || vuln.cveId || null,
      cvss: vuln.cvss || vuln.score || null,
      description: vuln.description || vuln.details || null,
      evidence: vuln.evidence || vuln.proof || null,
      recommendation: vuln.recommendation || vuln.remediation || vuln.fix || null,
      references: vuln.references || vuln.urls || []
    };
  }

  private _inferSeverity(vuln: any): string {
    const score = vuln.cvss || vuln.score;
    if (typeof score === 'number') {
      if (score >= 9) return 'critical';
      if (score >= 7) return 'high';
      if (score >= 4) return 'medium';
      return 'low';
    }
    return 'unknown';
  }

  private _parseRawVulns(raw: string): VulnerabilitiesData {
    const vulnerabilities: Vulnerability[] = [];
    const lines = raw.split('\n');

    for (const line of lines) {
      const vulnMatch = line.match(/\[(CRITICAL|HIGH|MEDIUM|LOW|INFO)\]\s*(.+)/i);
      if (vulnMatch) {
        vulnerabilities.push({
          severity: vulnMatch[1]!.toLowerCase(),
          title: vulnMatch[2]!.trim()
        });
      }
    }

    return {
      vulnerabilities,
      total: vulnerabilities.length
    };
  }

  async executeCmsScan(
    target: Target,
    cmsType: string,
    featureConfig: VulnerabilityFeatureConfig = {}
  ): Promise<VulnerabilityResult> {
    const url = this._buildUrl(target);
    const verb = `${cmsType}-scan`;

    const result = await this.commandRunner.runRedBlue(
      'web',
      'asset',
      verb,
      url,
      {
        timeout: featureConfig.timeout || 120000
      }
    );

    if (result.status !== 'ok') {
      return result as VulnerabilityResult;
    }

    return {
      status: 'ok',
      url,
      cms: cmsType,
      ...this._normalizeVulnerabilities(result.data),
      metadata: result.metadata
    };
  }
}
