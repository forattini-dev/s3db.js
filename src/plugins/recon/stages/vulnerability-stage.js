/**
 * VulnerabilityStage
 *
 * Vulnerability scanning using RedBlue:
 * - Web vulnerability detection
 * - CMS-specific scanning (WordPress, Drupal, Joomla)
 * - Auto-detection of CMS type
 */

export class VulnerabilityStage {
  constructor(plugin) {
    this.plugin = plugin;
    this.commandRunner = plugin.commandRunner;
    this.config = plugin.config;
  }

  async execute(target, featureConfig = {}) {
    const url = this._buildUrl(target);
    const strategy = featureConfig.strategy || 'auto';

    const result = await this.commandRunner.runRedBlue(
      'web',
      'asset',
      'scan',
      url,
      {
        timeout: featureConfig.timeout || 120000,
        flags: this._buildFlags(strategy, featureConfig)
      }
    );

    if (result.status === 'unavailable') {
      return {
        status: 'unavailable',
        message: 'RedBlue (rb) is not available',
        metadata: result.metadata
      };
    }

    if (result.status === 'error') {
      return {
        status: 'error',
        message: result.error,
        metadata: result.metadata
      };
    }

    const vulns = this._normalizeVulnerabilities(result.data);

    return {
      status: vulns.total > 0 ? 'ok' : 'empty',
      url,
      ...vulns,
      metadata: result.metadata
    };
  }

  _buildUrl(target) {
    const protocol = target.protocol || 'https';
    const port = target.port && target.port !== (protocol === 'http' ? 80 : 443)
      ? `:${target.port}`
      : '';
    return `${protocol}://${target.host}${port}${target.path || ''}`;
  }

  _buildFlags(strategy, config) {
    const flags = [];

    if (strategy !== 'auto') {
      flags.push('--strategy', strategy);
    }

    if (config.aggressive) {
      flags.push('--aggressive');
    }

    return flags;
  }

  _normalizeVulnerabilities(data) {
    if (!data || typeof data !== 'object') {
      return { vulnerabilities: [], total: 0 };
    }

    if (data.raw) {
      return this._parseRawVulns(data.raw);
    }

    const vulnerabilities = [];

    if (Array.isArray(data.vulnerabilities)) {
      vulnerabilities.push(...data.vulnerabilities.map(v => this._normalizeVuln(v)));
    } else if (Array.isArray(data)) {
      vulnerabilities.push(...data.map(v => this._normalizeVuln(v)));
    }

    if (data.findings) {
      vulnerabilities.push(...data.findings.map(v => this._normalizeVuln(v)));
    }

    return {
      vulnerabilities: vulnerabilities.filter(Boolean),
      total: vulnerabilities.length,
      cms: data.cms || data.detected_cms || null,
      version: data.version || data.detected_version || null,
      summary: data.summary || null
    };
  }

  _normalizeVuln(vuln) {
    if (!vuln) return null;

    if (typeof vuln === 'string') {
      return { title: vuln, severity: 'unknown' };
    }

    return {
      title: vuln.title || vuln.name || vuln.description || 'Unknown vulnerability',
      severity: vuln.severity || vuln.risk || this._inferSeverity(vuln),
      cve: vuln.cve || vuln.cveId || null,
      cvss: vuln.cvss || vuln.score || null,
      description: vuln.description || vuln.details || null,
      evidence: vuln.evidence || vuln.proof || null,
      recommendation: vuln.recommendation || vuln.remediation || vuln.fix || null,
      references: vuln.references || vuln.urls || []
    };
  }

  _inferSeverity(vuln) {
    const score = vuln.cvss || vuln.score;
    if (typeof score === 'number') {
      if (score >= 9) return 'critical';
      if (score >= 7) return 'high';
      if (score >= 4) return 'medium';
      return 'low';
    }
    return 'unknown';
  }

  _parseRawVulns(raw) {
    const vulnerabilities = [];
    const lines = raw.split('\n');

    for (const line of lines) {
      const vulnMatch = line.match(/\[(CRITICAL|HIGH|MEDIUM|LOW|INFO)\]\s*(.+)/i);
      if (vulnMatch) {
        vulnerabilities.push({
          severity: vulnMatch[1].toLowerCase(),
          title: vulnMatch[2].trim()
        });
      }
    }

    return {
      vulnerabilities,
      total: vulnerabilities.length
    };
  }

  async executeCmsScan(target, cmsType, featureConfig = {}) {
    const url = this._buildUrl(target);
    const verb = `${cmsType}-scan`;

    const result = await this.commandRunner.runRedBlue(
      'web',
      'asset',
      verb,
      url,
      {
        timeout: featureConfig.timeout || 120000
      }
    );

    if (result.status !== 'ok') {
      return result;
    }

    return {
      status: 'ok',
      url,
      cms: cmsType,
      ...this._normalizeVulnerabilities(result.data),
      metadata: result.metadata
    };
  }
}
