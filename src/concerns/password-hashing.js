/**
 * Password Hashing with bcrypt
 *
 * Provides secure one-way password hashing with space optimization.
 * Bcrypt hashes are 60 bytes, but we compact them to 52 bytes by removing
 * the version/rounds prefix ($2b$10$) which we can reconstruct.
 */

import bcrypt from 'bcrypt';
import { ValidationError } from '../errors.js';

/**
 * Hash a password using bcrypt (synchronous)
 * @param {string} password - Plaintext password
 * @param {number} [rounds=10] - Bcrypt cost factor (4-31, default 10)
 * @returns {string} Bcrypt hash (60 bytes)
 */
export function hashPasswordSync(password, rounds = 10) {
  if (!password || typeof password !== 'string') {
    throw new ValidationError('Password must be a non-empty string', {
      field: 'password',
      statusCode: 400,
      retriable: false,
      suggestion: 'Provide a non-empty string before calling hashPasswordSync().'
    });
  }

  if (rounds < 4 || rounds > 31) {
    throw new ValidationError('Bcrypt rounds must be between 4 and 31', {
      field: 'rounds',
      statusCode: 400,
      retriable: false,
      suggestion: 'Configure bcrypt rounds between 4 and 31 (inclusive).'
    });
  }

  return bcrypt.hashSync(password, rounds);
}

/**
 * Hash a password using bcrypt
 * @param {string} password - Plaintext password
 * @param {number} [rounds=10] - Bcrypt cost factor (4-31, default 10)
 * @returns {Promise<string>} Bcrypt hash (60 bytes)
 */
export async function hashPassword(password, rounds = 10) {
  if (!password || typeof password !== 'string') {
    throw new ValidationError('Password must be a non-empty string', {
      field: 'password',
      statusCode: 400,
      retriable: false,
      suggestion: 'Provide a non-empty string before calling hashPassword().'
    });
  }

  if (rounds < 4 || rounds > 31) {
    throw new ValidationError('Bcrypt rounds must be between 4 and 31', {
      field: 'rounds',
      statusCode: 400,
      retriable: false,
      suggestion: 'Configure bcrypt rounds between 4 and 31 (inclusive).'
    });
  }

  return await bcrypt.hash(password, rounds);
}

/**
 * Verify a password against a bcrypt hash
 * @param {string} plaintext - Plaintext password to verify
 * @param {string} hash - Bcrypt hash (can be full 60-byte or compact 52-byte)
 * @returns {Promise<boolean>} True if password matches
 */
export async function verifyPassword(plaintext, hash) {
  if (!plaintext || typeof plaintext !== 'string') {
    return false;
  }

  if (!hash || typeof hash !== 'string') {
    return false;
  }

  try {
    // If hash doesn't start with $, it's compacted - expand it first
    const fullHash = hash.startsWith('$') ? hash : expandHash(hash);
    return await bcrypt.compare(plaintext, fullHash);
  } catch (error) {
    // Invalid hash format
    return false;
  }
}

/**
 * Compact a bcrypt hash by removing the prefix
 *
 * Bcrypt format: $2b$10$saltsaltsaltsaltsalthashhashhashhashhashhashhashh
 * Compacted:     saltsaltsaltsaltsalthashhashhashhashhashhashhashh
 *
 * Saves 7 bytes (11.6% reduction: 60 â†’ 53 bytes)
 *
 * @param {string} bcryptHash - Full bcrypt hash (60 bytes)
 * @returns {string} Compacted hash (53 bytes)
 */
export function compactHash(bcryptHash) {
  if (!bcryptHash || typeof bcryptHash !== 'string') {
    throw new ValidationError('Invalid bcrypt hash', {
      field: 'bcryptHash',
      statusCode: 400,
      retriable: false,
      suggestion: 'Provide a valid bcrypt hash generated by hashPassword().'
    });
  }

  // Bcrypt format: $2a$10$ or $2b$10$ or $2y$10$
  if (!bcryptHash.startsWith('$2')) {
    throw new ValidationError('Not a valid bcrypt hash', {
      field: 'bcryptHash',
      statusCode: 400,
      retriable: false,
      suggestion: 'Ensure the hash starts with "$2" and was produced by bcrypt.'
    });
  }

  // Remove prefix (e.g., "$2b$10$")
  const parts = bcryptHash.split('$');
  if (parts.length !== 4) {
    throw new ValidationError('Invalid bcrypt hash format', {
      field: 'bcryptHash',
      statusCode: 400,
      retriable: false,
      suggestion: 'Provide a complete bcrypt hash (e.g., "$2b$10$...").'
    });
  }

  // Return just the salt+hash part (last element after split)
  return parts[3];
}

/**
 * Expand a compacted bcrypt hash by restoring the prefix
 *
 * @param {string} compactHash - Compacted hash (53 bytes)
 * @param {number} [rounds=10] - Bcrypt rounds used (default 10)
 * @returns {string} Full bcrypt hash (60 bytes)
 */
export function expandHash(compactHash, rounds = 10) {
  if (!compactHash || typeof compactHash !== 'string') {
    throw new ValidationError('Invalid compacted hash', {
      field: 'compactHash',
      statusCode: 400,
      retriable: false,
      suggestion: 'Provide a compacted hash returned from compactHash().'
    });
  }

  // If it's already a full hash, return as-is
  if (compactHash.startsWith('$')) {
    return compactHash;
  }

  // Reconstruct prefix: $2b${rounds}$
  const roundsStr = rounds.toString().padStart(2, '0');
  return `$2b$${roundsStr}$${compactHash}`;
}

/**
 * Check if a string is a bcrypt hash (full or compact)
 * @param {string} str - String to check
 * @returns {boolean} True if it looks like a bcrypt hash
 */
export function isBcryptHash(str) {
  if (!str || typeof str !== 'string') {
    return false;
  }

  // Full hash: starts with $2
  if (str.startsWith('$2')) {
    return str.length === 60;
  }

  // Compact hash: 53 characters (22 salt + 31 hash)
  return str.length === 53;
}

export default {
  hashPassword,
  verifyPassword,
  compactHash,
  expandHash,
  isBcryptHash
};
