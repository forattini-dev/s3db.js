import { ValidationError } from '../errors.js';

interface BcryptModule {
  hashSync: (password: string, rounds: number) => string;
  hash: (password: string, rounds: number) => Promise<string>;
  compare: (plaintext: string, hash: string) => Promise<boolean>;
}

let bcryptModule: BcryptModule | null = null;

async function getBcrypt(): Promise<BcryptModule> {
  if (bcryptModule) {
    return bcryptModule;
  }

  try {
    // @ts-expect-error bcrypt has no type declarations
    const module = await import('bcrypt');
    bcryptModule = (module.default || module) as BcryptModule;
    return bcryptModule;
  } catch {
    throw new ValidationError('bcrypt is not installed', {
      field: 'bcrypt',
      statusCode: 500,
      retriable: false,
      suggestion: 'Install bcrypt with: pnpm add bcrypt'
    });
  }
}

function getBcryptSync(): BcryptModule {
  if (!bcryptModule) {
    throw new ValidationError('bcrypt not loaded - call hashPassword() first or use the async version', {
      field: 'bcrypt',
      statusCode: 500,
      retriable: false,
      suggestion: 'Use hashPassword() (async) instead of hashPasswordSync(), or ensure bcrypt is loaded first.'
    });
  }
  return bcryptModule;
}

export function hashPasswordSync(password: string, rounds: number = 10): string {
  if (!password || typeof password !== 'string') {
    throw new ValidationError('Password must be a non-empty string', {
      field: 'password',
      statusCode: 400,
      retriable: false,
      suggestion: 'Provide a non-empty string before calling hashPasswordSync().'
    });
  }

  if (rounds < 4 || rounds > 31) {
    throw new ValidationError('Bcrypt rounds must be between 4 and 31', {
      field: 'rounds',
      statusCode: 400,
      retriable: false,
      suggestion: 'Configure bcrypt rounds between 4 and 31 (inclusive).'
    });
  }

  const bcrypt = getBcryptSync();
  return bcrypt.hashSync(password, rounds);
}

export async function hashPassword(password: string, rounds: number = 10): Promise<string> {
  if (!password || typeof password !== 'string') {
    throw new ValidationError('Password must be a non-empty string', {
      field: 'password',
      statusCode: 400,
      retriable: false,
      suggestion: 'Provide a non-empty string before calling hashPassword().'
    });
  }

  if (rounds < 4 || rounds > 31) {
    throw new ValidationError('Bcrypt rounds must be between 4 and 31', {
      field: 'rounds',
      statusCode: 400,
      retriable: false,
      suggestion: 'Configure bcrypt rounds between 4 and 31 (inclusive).'
    });
  }

  const bcrypt = await getBcrypt();
  const hashed = await bcrypt.hash(password, rounds);
  return hashed;
}

export async function verifyPassword(plaintext: string, hash: string): Promise<boolean> {
  if (!plaintext || typeof plaintext !== 'string') {
    return false;
  }

  if (!hash || typeof hash !== 'string') {
    return false;
  }

  try {
    const bcrypt = await getBcrypt();
    const fullHash = hash.startsWith('$') ? hash : expandHash(hash);
    const result = await bcrypt.compare(plaintext, fullHash);
    return result;
  } catch {
    return false;
  }
}

export function compactHash(bcryptHash: string): string {
  if (!bcryptHash || typeof bcryptHash !== 'string') {
    throw new ValidationError('Invalid bcrypt hash', {
      field: 'bcryptHash',
      statusCode: 400,
      retriable: false,
      suggestion: 'Provide a valid bcrypt hash generated by hashPassword().'
    });
  }

  if (!bcryptHash.startsWith('$2')) {
    throw new ValidationError('Not a valid bcrypt hash', {
      field: 'bcryptHash',
      statusCode: 400,
      retriable: false,
      suggestion: 'Ensure the hash starts with "$2" and was produced by bcrypt.'
    });
  }

  const parts = bcryptHash.split('$');
  if (parts.length !== 4) {
    throw new ValidationError('Invalid bcrypt hash format', {
      field: 'bcryptHash',
      statusCode: 400,
      retriable: false,
      suggestion: 'Provide a complete bcrypt hash (e.g., "$2b$10$...").'
    });
  }

  return parts[3]!;
}

export function expandHash(compactHashStr: string, rounds: number = 10): string {
  if (!compactHashStr || typeof compactHashStr !== 'string') {
    throw new ValidationError('Invalid compacted hash', {
      field: 'compactHash',
      statusCode: 400,
      retriable: false,
      suggestion: 'Provide a compacted hash returned from compactHash().'
    });
  }

  if (compactHashStr.startsWith('$')) {
    return compactHashStr;
  }

  const roundsStr = rounds.toString().padStart(2, '0');
  return `$2b$${roundsStr}$${compactHashStr}`;
}

export function isBcryptHash(str: string): boolean {
  if (!str || typeof str !== 'string') {
    return false;
  }

  if (str.startsWith('$2')) {
    return str.length === 60;
  }

  return str.length === 53;
}

export default {
  hashPassword,
  hashPasswordSync,
  verifyPassword,
  compactHash,
  expandHash,
  isBcryptHash
};
