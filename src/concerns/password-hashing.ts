// @ts-expect-error bcrypt has no type declarations
import bcrypt from 'bcrypt';
import { ValidationError } from '../errors.js';

export function hashPasswordSync(password: string, rounds: number = 10): string {
  if (!password || typeof password !== 'string') {
    throw new ValidationError('Password must be a non-empty string', {
      field: 'password',
      statusCode: 400,
      retriable: false,
      suggestion: 'Provide a non-empty string before calling hashPasswordSync().'
    });
  }

  if (rounds < 4 || rounds > 31) {
    throw new ValidationError('Bcrypt rounds must be between 4 and 31', {
      field: 'rounds',
      statusCode: 400,
      retriable: false,
      suggestion: 'Configure bcrypt rounds between 4 and 31 (inclusive).'
    });
  }

  return bcrypt.hashSync(password, rounds);
}

export async function hashPassword(password: string, rounds: number = 10): Promise<string> {
  if (!password || typeof password !== 'string') {
    throw new ValidationError('Password must be a non-empty string', {
      field: 'password',
      statusCode: 400,
      retriable: false,
      suggestion: 'Provide a non-empty string before calling hashPassword().'
    });
  }

  if (rounds < 4 || rounds > 31) {
    throw new ValidationError('Bcrypt rounds must be between 4 and 31', {
      field: 'rounds',
      statusCode: 400,
      retriable: false,
      suggestion: 'Configure bcrypt rounds between 4 and 31 (inclusive).'
    });
  }

  const hashed = await bcrypt.hash(password, rounds);
  return hashed;
}

export async function verifyPassword(plaintext: string, hash: string): Promise<boolean> {
  if (!plaintext || typeof plaintext !== 'string') {
    return false;
  }

  if (!hash || typeof hash !== 'string') {
    return false;
  }

  try {
    const fullHash = hash.startsWith('$') ? hash : expandHash(hash);
    const result = await bcrypt.compare(plaintext, fullHash);
    return result;
  } catch {
    return false;
  }
}

export function compactHash(bcryptHash: string): string {
  if (!bcryptHash || typeof bcryptHash !== 'string') {
    throw new ValidationError('Invalid bcrypt hash', {
      field: 'bcryptHash',
      statusCode: 400,
      retriable: false,
      suggestion: 'Provide a valid bcrypt hash generated by hashPassword().'
    });
  }

  if (!bcryptHash.startsWith('$2')) {
    throw new ValidationError('Not a valid bcrypt hash', {
      field: 'bcryptHash',
      statusCode: 400,
      retriable: false,
      suggestion: 'Ensure the hash starts with "$2" and was produced by bcrypt.'
    });
  }

  const parts = bcryptHash.split('$');
  if (parts.length !== 4) {
    throw new ValidationError('Invalid bcrypt hash format', {
      field: 'bcryptHash',
      statusCode: 400,
      retriable: false,
      suggestion: 'Provide a complete bcrypt hash (e.g., "$2b$10$...").'
    });
  }

  return parts[3]!;
}

export function expandHash(compactHashStr: string, rounds: number = 10): string {
  if (!compactHashStr || typeof compactHashStr !== 'string') {
    throw new ValidationError('Invalid compacted hash', {
      field: 'compactHash',
      statusCode: 400,
      retriable: false,
      suggestion: 'Provide a compacted hash returned from compactHash().'
    });
  }

  if (compactHashStr.startsWith('$')) {
    return compactHashStr;
  }

  const roundsStr = rounds.toString().padStart(2, '0');
  return `$2b$${roundsStr}$${compactHashStr}`;
}

export function isBcryptHash(str: string): boolean {
  if (!str || typeof str !== 'string') {
    return false;
  }

  if (str.startsWith('$2')) {
    return str.length === 60;
  }

  return str.length === 53;
}

export default {
  hashPassword,
  hashPasswordSync,
  verifyPassword,
  compactHash,
  expandHash,
  isBcryptHash
};
