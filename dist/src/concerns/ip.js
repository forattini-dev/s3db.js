/**
 * IP Address Encoding/Decoding Utilities
 *
 * Provides compact binary encoding for IPv4 and IPv6 addresses
 * to save space in S3 metadata.
 */
import { tryFnSync } from './try-fn.js';
import { ValidationError } from '../errors.js';
/**
 * Validate IPv4 address format
 */
export function isValidIPv4(ip) {
    if (typeof ip !== 'string')
        return false;
    const ipv4Regex = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
    const match = ip.match(ipv4Regex);
    if (!match)
        return false;
    for (let i = 1; i <= 4; i++) {
        const octet = parseInt(match[i], 10);
        if (octet < 0 || octet > 255)
            return false;
    }
    return true;
}
/**
 * Validate IPv6 address format
 */
export function isValidIPv6(ip) {
    if (typeof ip !== 'string')
        return false;
    const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]+|::(ffff(:0{1,4})?:)?((25[0-5]|(2[0-4]|1?[0-9])?[0-9])\.){3}(25[0-5]|(2[0-4]|1?[0-9])?[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1?[0-9])?[0-9])\.){3}(25[0-5]|(2[0-4]|1?[0-9])?[0-9]))$/;
    return ipv6Regex.test(ip);
}
/**
 * Encode IPv4 address to Base64 binary representation
 */
export function encodeIPv4(ip) {
    if (!isValidIPv4(ip)) {
        throw new ValidationError('Invalid IPv4 address', {
            field: 'ip',
            value: ip,
            retriable: false,
            suggestion: 'Provide a valid IPv4 address (e.g., "192.168.0.1").'
        });
    }
    const octets = ip.split('.').map(octet => parseInt(octet, 10));
    const buffer = Buffer.from(octets);
    return buffer.toString('base64');
}
/**
 * Decode Base64 binary to IPv4 address
 */
export function decodeIPv4(encoded) {
    if (typeof encoded !== 'string') {
        throw new ValidationError('Encoded IPv4 must be a string', {
            field: 'encoded',
            retriable: false,
            suggestion: 'Pass the base64-encoded IPv4 string returned by encodeIPv4().'
        });
    }
    const [ok, err, result] = tryFnSync(() => {
        const buffer = Buffer.from(encoded, 'base64');
        if (buffer.length !== 4) {
            throw new ValidationError('Invalid encoded IPv4 length', {
                field: 'encoded',
                value: encoded,
                retriable: false,
                suggestion: 'Ensure the encoded IPv4 string was produced by encodeIPv4().'
            });
        }
        return Array.from(buffer).join('.');
    });
    if (!ok) {
        if (err instanceof ValidationError) {
            throw err;
        }
        throw new ValidationError('Failed to decode IPv4', {
            field: 'encoded',
            retriable: false,
            suggestion: 'Confirm the value is a base64-encoded IPv4 string generated by encodeIPv4().',
            original: err
        });
    }
    return result;
}
/**
 * Normalize IPv6 address to full expanded form
 */
export function expandIPv6(ip) {
    if (!isValidIPv6(ip)) {
        throw new ValidationError('Invalid IPv6 address', {
            field: 'ip',
            value: ip,
            retriable: false,
            suggestion: 'Provide a valid IPv6 address (e.g., "2001:db8::1").'
        });
    }
    let expanded = ip;
    if (expanded === '::') {
        return '0000:0000:0000:0000:0000:0000:0000:0000';
    }
    if (expanded.includes('::')) {
        const parts = expanded.split('::');
        const leftParts = parts[0] ? parts[0].split(':') : [];
        const rightParts = parts[1] ? parts[1].split(':') : [];
        const missingGroups = 8 - leftParts.length - rightParts.length;
        const middleParts = Array(missingGroups).fill('0');
        expanded = [...leftParts, ...middleParts, ...rightParts].join(':');
    }
    const groups = expanded.split(':');
    const paddedGroups = groups.map(group => group.padStart(4, '0'));
    return paddedGroups.join(':');
}
/**
 * Compress IPv6 address (remove leading zeros and use ::)
 */
export function compressIPv6(ip) {
    let compressed = ip.split(':').map(group => {
        return parseInt(group, 16).toString(16);
    }).join(':');
    const zeroSequences = [];
    let currentSequence = { start: -1, length: 0 };
    compressed.split(':').forEach((group, index) => {
        if (group === '0') {
            if (currentSequence.start === -1) {
                currentSequence.start = index;
                currentSequence.length = 1;
            }
            else {
                currentSequence.length++;
            }
        }
        else {
            if (currentSequence.length > 0) {
                zeroSequences.push({ ...currentSequence });
                currentSequence = { start: -1, length: 0 };
            }
        }
    });
    if (currentSequence.length > 0) {
        zeroSequences.push(currentSequence);
    }
    const longestSequence = zeroSequences
        .filter(seq => seq.length >= 2)
        .sort((a, b) => b.length - a.length)[0];
    if (longestSequence) {
        const parts = compressed.split(':');
        const before = parts.slice(0, longestSequence.start).join(':');
        const after = parts.slice(longestSequence.start + longestSequence.length).join(':');
        if (before && after) {
            compressed = `${before}::${after}`;
        }
        else if (before) {
            compressed = `${before}::`;
        }
        else if (after) {
            compressed = `::${after}`;
        }
        else {
            compressed = '::';
        }
    }
    return compressed;
}
/**
 * Encode IPv6 address to Base64 binary representation
 */
export function encodeIPv6(ip) {
    if (!isValidIPv6(ip)) {
        throw new ValidationError('Invalid IPv6 address', {
            field: 'ip',
            value: ip,
            retriable: false,
            suggestion: 'Provide a valid IPv6 address (e.g., "2001:db8::1").'
        });
    }
    const expanded = expandIPv6(ip);
    const groups = expanded.split(':');
    const bytes = [];
    for (const group of groups) {
        const value = parseInt(group, 16);
        bytes.push((value >> 8) & 0xFF);
        bytes.push(value & 0xFF);
    }
    const buffer = Buffer.from(bytes);
    return buffer.toString('base64');
}
/**
 * Decode Base64 binary to IPv6 address
 */
export function decodeIPv6(encoded, compress = true) {
    if (typeof encoded !== 'string') {
        throw new ValidationError('Encoded IPv6 must be a string', {
            field: 'encoded',
            retriable: false,
            suggestion: 'Pass the base64-encoded IPv6 string returned by encodeIPv6().'
        });
    }
    if (encoded.length !== 24 && isValidIPv6(encoded)) {
        return compress ? encoded : expandIPv6(encoded);
    }
    const [ok, err, result] = tryFnSync(() => {
        const buffer = Buffer.from(encoded, 'base64');
        if (buffer.length !== 16) {
            throw new ValidationError('Invalid encoded IPv6 length', {
                field: 'encoded',
                value: encoded,
                retriable: false,
                suggestion: 'Ensure the encoded IPv6 string was produced by encodeIPv6().'
            });
        }
        const groups = [];
        for (let i = 0; i < 16; i += 2) {
            const value = (buffer[i] << 8) | buffer[i + 1];
            groups.push(value.toString(16).padStart(4, '0'));
        }
        const fullAddress = groups.join(':');
        return compress ? compressIPv6(fullAddress) : fullAddress;
    });
    if (!ok) {
        if (err instanceof ValidationError) {
            throw err;
        }
        throw new ValidationError('Failed to decode IPv6', {
            field: 'encoded',
            retriable: false,
            suggestion: 'Confirm the value is a base64-encoded IPv6 string generated by encodeIPv6().',
            original: err
        });
    }
    return result;
}
/**
 * Detect IP version from string
 */
export function detectIPVersion(ip) {
    if (isValidIPv4(ip))
        return 'ipv4';
    if (isValidIPv6(ip))
        return 'ipv6';
    return null;
}
/**
 * Calculate savings percentage for IP encoding
 */
export function calculateIPSavings(ip) {
    const version = detectIPVersion(ip);
    if (!version) {
        return { version: null, originalSize: 0, encodedSize: 0, savings: 0 };
    }
    const originalSize = ip.length;
    let encodedSize;
    if (version === 'ipv4') {
        const encoded = encodeIPv4(ip);
        encodedSize = encoded.length;
    }
    else {
        const encoded = encodeIPv6(ip);
        encodedSize = encoded.length;
    }
    const savings = ((originalSize - encodedSize) / originalSize) * 100;
    return {
        version,
        originalSize,
        encodedSize,
        savings: Math.round(savings * 100) / 100,
        savingsPercent: `${Math.round(savings)}%`
    };
}
export default {
    isValidIPv4,
    isValidIPv6,
    encodeIPv4,
    decodeIPv4,
    encodeIPv6,
    decodeIPv6,
    expandIPv6,
    compressIPv6,
    detectIPVersion,
    calculateIPSavings
};
//# sourceMappingURL=ip.js.map