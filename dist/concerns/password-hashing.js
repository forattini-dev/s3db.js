import { ValidationError } from '../errors.js';
let bcryptModule = null;
async function getBcrypt() {
    if (bcryptModule) {
        return bcryptModule;
    }
    try {
        // @ts-expect-error bcrypt has no type declarations
        const module = await import('bcrypt');
        bcryptModule = (module.default || module);
        return bcryptModule;
    }
    catch {
        throw new ValidationError('bcrypt is not installed', {
            field: 'bcrypt',
            statusCode: 500,
            retriable: false,
            suggestion: 'Install bcrypt with: pnpm add bcrypt'
        });
    }
}
function getBcryptSync() {
    if (!bcryptModule) {
        throw new ValidationError('bcrypt not loaded - call hashPassword() first or use the async version', {
            field: 'bcrypt',
            statusCode: 500,
            retriable: false,
            suggestion: 'Use hashPassword() (async) instead of hashPasswordSync(), or ensure bcrypt is loaded first.'
        });
    }
    return bcryptModule;
}
export function hashPasswordSync(password, rounds = 10) {
    if (!password || typeof password !== 'string') {
        throw new ValidationError('Password must be a non-empty string', {
            field: 'password',
            statusCode: 400,
            retriable: false,
            suggestion: 'Provide a non-empty string before calling hashPasswordSync().'
        });
    }
    if (rounds < 4 || rounds > 31) {
        throw new ValidationError('Bcrypt rounds must be between 4 and 31', {
            field: 'rounds',
            statusCode: 400,
            retriable: false,
            suggestion: 'Configure bcrypt rounds between 4 and 31 (inclusive).'
        });
    }
    const bcrypt = getBcryptSync();
    return bcrypt.hashSync(password, rounds);
}
export async function hashPassword(password, rounds = 10) {
    if (!password || typeof password !== 'string') {
        throw new ValidationError('Password must be a non-empty string', {
            field: 'password',
            statusCode: 400,
            retriable: false,
            suggestion: 'Provide a non-empty string before calling hashPassword().'
        });
    }
    if (rounds < 4 || rounds > 31) {
        throw new ValidationError('Bcrypt rounds must be between 4 and 31', {
            field: 'rounds',
            statusCode: 400,
            retriable: false,
            suggestion: 'Configure bcrypt rounds between 4 and 31 (inclusive).'
        });
    }
    const bcrypt = await getBcrypt();
    const hashed = await bcrypt.hash(password, rounds);
    return hashed;
}
export async function verifyPassword(plaintext, hash) {
    if (!plaintext || typeof plaintext !== 'string') {
        return false;
    }
    if (!hash || typeof hash !== 'string') {
        return false;
    }
    try {
        const bcrypt = await getBcrypt();
        const fullHash = hash.startsWith('$') ? hash : expandHash(hash);
        const result = await bcrypt.compare(plaintext, fullHash);
        return result;
    }
    catch {
        return false;
    }
}
export function compactHash(bcryptHash) {
    if (!bcryptHash || typeof bcryptHash !== 'string') {
        throw new ValidationError('Invalid bcrypt hash', {
            field: 'bcryptHash',
            statusCode: 400,
            retriable: false,
            suggestion: 'Provide a valid bcrypt hash generated by hashPassword().'
        });
    }
    if (!bcryptHash.startsWith('$2')) {
        throw new ValidationError('Not a valid bcrypt hash', {
            field: 'bcryptHash',
            statusCode: 400,
            retriable: false,
            suggestion: 'Ensure the hash starts with "$2" and was produced by bcrypt.'
        });
    }
    const parts = bcryptHash.split('$');
    if (parts.length !== 4) {
        throw new ValidationError('Invalid bcrypt hash format', {
            field: 'bcryptHash',
            statusCode: 400,
            retriable: false,
            suggestion: 'Provide a complete bcrypt hash (e.g., "$2b$10$...").'
        });
    }
    return parts[3];
}
export function expandHash(compactHashStr, rounds = 10) {
    if (!compactHashStr || typeof compactHashStr !== 'string') {
        throw new ValidationError('Invalid compacted hash', {
            field: 'compactHash',
            statusCode: 400,
            retriable: false,
            suggestion: 'Provide a compacted hash returned from compactHash().'
        });
    }
    if (compactHashStr.startsWith('$')) {
        return compactHashStr;
    }
    const roundsStr = rounds.toString().padStart(2, '0');
    return `$2b$${roundsStr}$${compactHashStr}`;
}
export function isBcryptHash(str) {
    if (!str || typeof str !== 'string') {
        return false;
    }
    if (str.startsWith('$2')) {
        return str.length === 60;
    }
    return str.length === 53;
}
export default {
    hashPassword,
    hashPasswordSync,
    verifyPassword,
    compactHash,
    expandHash,
    isBcryptHash
};
//# sourceMappingURL=password-hashing.js.map