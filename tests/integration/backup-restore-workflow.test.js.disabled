import { describe, expect, test, beforeAll, afterAll } from '@jest/globals';
import { S3db } from '../../src/index.js';
import { BackupPlugin } from '../../src/plugins/backup.plugin.js';
import { spawn } from 'child_process';
import path from 'path';
import fs from 'fs/promises';
import { createDatabaseForTest, createTemporaryPathForTest } from '../config.js';

describe('Backup & Restore Workflow Integration', () => {
  let database;
  let connectionString;
  let tempBackupDir;
  let testResourceName = 'workflow_test_users';

  beforeAll(async () => {
    // Create database
    database = createDatabaseForTest('suite=integration/backup-restore-workflow');
    await database.connect();
    connectionString = database.connectionString;

    // Create temp directory for backups
    tempBackupDir = await createTemporaryPathForTest('workflow-backup-test');

    // Install backup plugin (new driver API)
    const backupPlugin = new BackupPlugin({
      driver: 'filesystem',
      config: {
        path: tempBackupDir + '/{date}/'
      },
      compression: 'gzip',
      verbose: false
    });

    await database.usePlugin(backupPlugin);

    // Create test resource with sample data
    const users = await database.createResource({
      name: testResourceName,
      attributes: {
        id: 'string|required',
        name: 'string|required',
        email: 'string|required',
        department: 'string|required',
        salary: 'number|default:50000',
        active: 'boolean|default:true'
      },
      behavior: 'body-overflow',
      timestamps: true
    });

    // Insert comprehensive test data
    const testUsers = [
      { id: 'user001', name: 'Alice Johnson', email: 'alice@company.com', department: 'Engineering', salary: 85000, active: true },
      { id: 'user002', name: 'Bob Smith', email: 'bob@company.com', department: 'Marketing', salary: 65000, active: true },
      { id: 'user003', name: 'Carol Williams', email: 'carol@company.com', department: 'Sales', salary: 70000, active: true },
      { id: 'user004', name: 'David Brown', email: 'david@company.com', department: 'Engineering', salary: 90000, active: false },
      { id: 'user005', name: 'Eva Davis', email: 'eva@company.com', department: 'HR', salary: 60000, active: true }
    ];

    for (const user of testUsers) {
      await users.insert(user);
    }

    console.log(`✓ Test database setup complete with ${testUsers.length} users`);
  });

  afterAll(async () => {
    if (database) {
      await database.disconnect();
    }
    
    // Cleanup temp directory
    if (tempBackupDir) {
      try {
        await fs.rmdir(tempBackupDir, { recursive: true });
      } catch (err) {
        // Ignore cleanup errors
      }
    }
  });

  test('Complete CLI backup and restore workflow', async () => {
    const users = database.resources[testResourceName];

    // Step 1: Verify initial state
    console.log('📊 Step 1: Verifying initial data...');
    const initialCount = await users.count();
    expect(initialCount).toBe(5);

    const initialUsers = await users.list();
    expect(initialUsers).toHaveLength(5);
    expect(initialUsers.find(u => u.id === 'user001').name).toBe('Alice Johnson');

    // Step 2: Create backup via CLI
    console.log('💾 Step 2: Creating backup via CLI...');
    const backupResult = await runCLICommand(['backup', 'full', '--connection', connectionString]);
    expect(backupResult.code).toBe(0);
    expect(backupResult.stdout).toContain('✓ full backup created successfully');

    // Extract backup ID
    const backupIdMatch = backupResult.stdout.match(/Backup ID:\s*(\S+)/);
    expect(backupIdMatch).toBeTruthy();
    const backupId = backupIdMatch[1];
    console.log(`📦 Backup created with ID: ${backupId}`);

    // Step 3: Verify backup was created properly
    console.log('🔍 Step 3: Verifying backup status...');
    const statusResult = await runCLICommand(['backup', '--status', backupId, '--connection', connectionString]);
    expect(statusResult.code).toBe(0);
    expect(statusResult.stdout).toContain('Status: ✓ completed');
    expect(statusResult.stdout).toContain(`Resources: ${testResourceName}`);

    // Step 4: Modify data significantly
    console.log('🔄 Step 4: Modifying data...');
    await users.delete('user001'); // Delete Alice
    await users.delete('user002'); // Delete Bob
    await users.update('user003', { name: 'Carol MODIFIED', salary: 999999 }); // Modify Carol
    await users.insert({ id: 'user006', name: 'Frank New', email: 'frank@company.com', department: 'IT', salary: 55000, active: true });

    // Verify modifications
    const modifiedCount = await users.count();
    expect(modifiedCount).toBe(4); // 5 - 2 deleted + 1 new = 4

    const carol = await users.get('user003');
    expect(carol.name).toBe('Carol MODIFIED');
    expect(carol.salary).toBe(999999);

    const alice = await users.get('user001');
    expect(alice).toBeNull();

    const frank = await users.get('user006');
    expect(frank.name).toBe('Frank New');

    // Step 5: List backups via CLI
    console.log('📋 Step 5: Listing backups...');
    const listResult = await runCLICommand(['backup', '--list', '--connection', connectionString]);
    expect(listResult.code).toBe(0);
    expect(listResult.stdout).toContain(backupId);
    expect(listResult.stdout).toContain('full');
    expect(listResult.stdout).toContain('✓');

    // Step 6: Restore via CLI
    console.log('🔄 Step 6: Restoring from backup...');
    const restoreResult = await runCLICommand(['restore', backupId, '--overwrite', '--connection', connectionString]);
    expect(restoreResult.code).toBe(0);
    expect(restoreResult.stdout).toContain('✓ Restore completed successfully');
    expect(restoreResult.stdout).toContain(`Backup ID: ${backupId}`);
    expect(restoreResult.stdout).toContain(`Resources restored: ${testResourceName}`);

    // Step 7: Verify restoration
    console.log('✅ Step 7: Verifying restoration...');
    const restoredCount = await users.count();
    expect(restoredCount).toBe(5); // Back to original 5 users

    // Verify specific users are restored
    const restoredAlice = await users.get('user001');
    expect(restoredAlice).toBeTruthy();
    expect(restoredAlice.name).toBe('Alice Johnson');
    expect(restoredAlice.salary).toBe(85000);

    const restoredBob = await users.get('user002');
    expect(restoredBob).toBeTruthy();
    expect(restoredBob.name).toBe('Bob Smith');

    const restoredCarol = await users.get('user003');
    expect(restoredCarol).toBeTruthy();
    expect(restoredCarol.name).toBe('Carol Williams'); // Back to original
    expect(restoredCarol.salary).toBe(70000); // Back to original

    // Verify Frank (new user) is gone
    const frankAfterRestore = await users.get('user006');
    expect(frankAfterRestore).toBeNull();

    console.log('🎉 Workflow test completed successfully!');
  });

  test('Selective resource backup and restore', async () => {
    // Create additional resource for selective testing
    const orders = await database.createResource({
      name: 'test_orders',
      attributes: {
        id: 'string|required',
        userId: 'string|required',
        amount: 'number|required',
        status: 'string|default:pending'
      }
    });

    // Add test orders
    await orders.insert({ id: 'order001', userId: 'user001', amount: 100.50, status: 'completed' });
    await orders.insert({ id: 'order002', userId: 'user002', amount: 75.25, status: 'pending' });

    // Create backup of specific resource only
    console.log('📦 Creating selective backup...');
    const backupResult = await runCLICommand([
      'backup', 'full', 
      '--resources', testResourceName,
      '--connection', connectionString
    ]);
    expect(backupResult.code).toBe(0);
    expect(backupResult.stdout).toContain(`Resources: ${testResourceName}`);

    const backupId = backupResult.stdout.match(/Backup ID:\s*(\S+)/)[1];

    // Delete data from both resources
    const users = database.resources[testResourceName];
    await users.delete('user001');
    await orders.delete('order001');

    // Restore only the users resource
    console.log('🔄 Restoring selective backup...');
    const restoreResult = await runCLICommand([
      'restore', backupId,
      '--resources', testResourceName,
      '--connection', connectionString
    ]);
    expect(restoreResult.code).toBe(0);

    // Verify users was restored but orders was not
    const restoredUser = await users.get('user001');
    expect(restoredUser).toBeTruthy();

    const orderStillDeleted = await orders.get('order001');
    expect(orderStillDeleted).toBeNull(); // Should still be deleted

    // Cleanup
    await database.deleteResource('test_orders');
  });

  test('Incremental backup workflow', async () => {
    // Create initial full backup
    console.log('📦 Creating full backup...');
    const fullBackupResult = await runCLICommand(['backup', 'full', '--connection', connectionString]);
    expect(fullBackupResult.code).toBe(0);
    const fullBackupId = fullBackupResult.stdout.match(/Backup ID:\s*(\S+)/)[1];

    // Make some changes
    const users = database.resources[testResourceName];
    await users.insert({ id: 'user007', name: 'Grace New', email: 'grace@company.com', department: 'Finance', salary: 65000 });

    // Create incremental backup
    console.log('📦 Creating incremental backup...');
    const incBackupResult = await runCLICommand(['backup', 'incremental', '--connection', connectionString]);
    expect(incBackupResult.code).toBe(0);
    expect(incBackupResult.stdout).toContain('✓ incremental backup created successfully');
    const incBackupId = incBackupResult.stdout.match(/Backup ID:\s*(\S+)/)[1];

    // List both backups
    const listResult = await runCLICommand(['backup', '--list', '--connection', connectionString]);
    expect(listResult.stdout).toContain(fullBackupId);
    expect(listResult.stdout).toContain(incBackupId);
    expect(listResult.stdout).toContain('full');
    expect(listResult.stdout).toContain('incremental');

    // Test restore from incremental
    await users.delete('user007');
    const restoreResult = await runCLICommand(['restore', incBackupId, '--connection', connectionString]);
    expect(restoreResult.code).toBe(0);

    const restoredGrace = await users.get('user007');
    expect(restoredGrace).toBeTruthy();
    expect(restoredGrace.name).toBe('Grace New');
  });

  test('Error scenarios and recovery', async () => {
    // Test restore with non-existent backup
    console.log('🚫 Testing non-existent backup...');
    const badRestoreResult = await runCLICommand(['restore', 'non-existent-backup', '--connection', connectionString]);
    expect(badRestoreResult.code).toBe(1);
    expect(badRestoreResult.stderr).toContain("Backup 'non-existent-backup' not found");

    // Test backup status for non-existent backup
    const badStatusResult = await runCLICommand(['backup', '--status', 'non-existent-backup', '--connection', connectionString]);
    expect(badStatusResult.code).toBe(0); // Should not crash
    expect(badStatusResult.stdout).toContain("Backup 'non-existent-backup' not found");

    // Test invalid backup type
    const invalidTypeResult = await runCLICommand(['backup', 'invalid-type', '--connection', connectionString]);
    expect(invalidTypeResult.code).toBe(1);
    expect(invalidTypeResult.stderr).toContain("Invalid backup type 'invalid-type'");
  });

  // Helper function to run CLI commands with better error handling
  async function runCLICommand(args, timeout = 30000) {
    const cliPath = path.join(process.cwd(), 'bin', 's3db-cli.js');
    
    return new Promise((resolve) => {
      const child = spawn('node', [cliPath, ...args], {
        stdio: ['pipe', 'pipe', 'pipe'],
        env: { ...process.env, NODE_ENV: 'test' }
      });

      let stdout = '';
      let stderr = '';

      child.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      child.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      child.on('close', (code) => {
        resolve({ code, stdout, stderr });
      });

      child.on('error', (error) => {
        resolve({ code: -1, stdout, stderr: `Process error: ${error.message}` });
      });

      // Timeout handling
      const timer = setTimeout(() => {
        child.kill('SIGTERM');
        setTimeout(() => {
          child.kill('SIGKILL');
        }, 5000);
        resolve({ code: -1, stdout, stderr: `Timeout after ${timeout}ms` });
      }, timeout);

      child.on('close', () => {
        clearTimeout(timer);
      });
    });
  }
});